package templates

import (
	"fmt"
	"math"
	"net/url"
)

// AlertDisplay holds display data for a service alert.
type AlertDisplay struct {
	HeaderText string
	DescText   string
	Effect     string // Human-readable: "Detour", "No Service", etc.
}

// NearbyData holds the data for the nearby departures page.
type NearbyData struct {
	Page     Page
	View     string // "routes" or "stops"
	Routes   []RouteNearbyRow
	StopViews []StopViewData
	HasStops bool
	HasMore  bool
	MoreURL  string
	Query    string // search query (for display / tab URLs)
	Lat      string
	Lon      string
	Alerts   []AlertDisplay
}

// RouteNearbyRow holds data for a single route in the routes-first nearby view.
type RouteNearbyRow struct {
	RouteID        string
	RouteShort     string
	RouteColor     string
	RouteTextColor string
	RouteName      string // headsign / destination
	DirectionText  string
	DirectionID    int
	StopID         string
	StopName       string
	DistanceM      float64 // straight-line distance in meters (for display)
	WalkDistM      float64 // Manhattan distance in meters (for walk time)

	Scheduled   string
	Realtime    string
	MinutesAway int
	IsRealtime  bool
	IsLate      bool

	LaterTimes []LaterArrival
	Interval   string // "Every 20 min until 8:00 PM" or ""

	// Alt direction (cross-stop pairing)
	HasAlt           bool
	AltDirectionText string
	AltStopID        string
	AltStopName      string
	AltRouteName     string
	AltScheduled     string
	AltRealtime      string
	AltMinutesAway   int
	AltIsRealtime    bool
	AltIsLate        bool
	AltLaterTimes    []LaterArrival
	AltInterval      string
	AltDistanceM     float64
	AltWalkDistM     float64
}

// LaterArrival holds a later departure time for a route group.
type LaterArrival struct {
	Time        string
	MinutesAway int
	IsRealtime  bool
}

// StopViewData holds data for a single stop in the stops-centric view.
type StopViewData struct {
	StopID      string
	StopName    string
	StopDesc    string  // Disambiguation label, e.g. "Southbound side"
	DistanceM   float64 // straight-line distance in meters (for display)
	WalkDistM   float64 // Manhattan distance in meters (for walk time)
	RouteGroups []StopRouteGroup
}

// StopRouteGroup is a route at a stop with its upcoming departures.
type StopRouteGroup struct {
	RouteID        string
	RouteShort     string
	RouteColor     string
	RouteTextColor string
	DirectionText  string
	Headsign       string
	Times          []StopRouteDeparture
}

// StopRouteDeparture is a single departure time within a route group.
type StopRouteDeparture struct {
	Scheduled   string
	Realtime    string
	MinutesAway int
	IsRealtime  bool
	IsLate      bool
}

//DepartureInfo holds departure display data.
type DepartureInfo struct {
	RouteID        string
	RouteShort     string
	RouteColor     string
	RouteTextColor string
	Headsign       string
	DirectionText  string // "Eastbound", "Westbound", etc.
	DirectionID    int
	Scheduled      string // e.g. "3:45 PM"
	Realtime       string // e.g. "3:47 PM" or empty if no realtime
	MinutesAway    int
	IsRealtime     bool
	IsLate         bool

	// Alternate direction (cross-stop pairing in nearby view)
	HasAlt           bool
	AltDirectionText string
	AltHeadsign      string
	AltScheduled     string
	AltRealtime      string
	AltMinutesAway   int
	AltIsRealtime    bool
	AltIsLate        bool
	AltStopName      string // Name of the stop for the alt direction
	PrimaryStopName  string // Name of this departure's stop (for comparison)
}

// NearbyPage renders the full nearby departures page.
templ NearbyPage(data NearbyData) {
	@Layout(data.Page) {
		<section aria-label="Nearby departures">
			<div class="nearby-header">
				<h2>Nearby Departures</h2>
				<div class="nearby-header-right">
					if data.Query == "" && data.Lat != "" {
						<span
							class="location-label"
							role="status"
							aria-label={ "Current location: " + nearbyLocationLabel(data) }
							hx-get={ fmt.Sprintf("/api/location-label?lat=%s&lon=%s", data.Lat, data.Lon) }
							hx-trigger="load"
							hx-swap="outerHTML"
						>
							if nearbyLocationLabel(data) != "" {
								{ nearbyLocationLabel(data) }
							}
						</span>
					} else if nearbyLocationLabel(data) != "" {
						<span class="location-label" role="status" aria-label={ "Current location: " + nearbyLocationLabel(data) }>{ nearbyLocationLabel(data) }</span>
					}
					<a href={ templ.SafeURL(fmt.Sprintf("/search?view=%s", data.View)) } class="change-location-link" aria-label="Change location">Change</a>
					if data.Lat != "" {
						<button id="unit-toggle" class="unit-toggle" type="button" aria-label="Distance in meters. Click to switch to miles.">m</button>
					}
				</div>
			</div>
			<div id="saved-locations" aria-label="Saved locations" hidden></div>
			<div id="location-status" aria-live="polite"></div>
			<form id="nearby-form" action="/nearby" method="get" hidden>
				<input type="hidden" id="lat" name="lat" value={ data.Lat }/>
				<input type="hidden" id="lon" name="lon" value={ data.Lon }/>
				<input type="hidden" id="view" name="view" value={ data.View }/>
			</form>
			if data.Lat != "" {
				<nav aria-label="View options" class="nearby-tabs">
					<a
						href={ templ.SafeURL(nearbyTabURL("routes", data.Lat, data.Lon, data.Query)) }
						class="nearby-tab"
						if data.View == "routes" {
							aria-current="page"
						}
					>
						Routes nearby
					</a>
					<a
						href={ templ.SafeURL(nearbyTabURL("stops", data.Lat, data.Lon, data.Query)) }
						class="nearby-tab"
						if data.View == "stops" {
							aria-current="page"
						}
					>
						Stops nearby
					</a>
				</nav>
			}
			if len(data.Alerts) > 0 {
				@AlertSection(data.Alerts)
			}
			<div id="stop-list" aria-live="polite">
				if data.HasStops {
					if data.View == "stops" {
						<div id="stop-list-items">
							@NearbyStopsViewList(data.StopViews)
						</div>
						<div id="load-more-stops">
							if data.HasMore {
								<button
									class="btn-more"
									hx-get={ data.MoreURL }
									hx-target="#stop-list-items"
									hx-swap="beforeend"
									hx-indicator="#loading-more-stops"
								>
									Show more stops
								</button>
								<span id="loading-more-stops" class="htmx-indicator loading">Loading…</span>
							}
						</div>
					} else {
						<div id="route-list">
							@RouteNearbyList(data.Routes)
						</div>
						<div id="load-more">
							if data.HasMore {
								<button
									class="btn-more"
									hx-get={ data.MoreURL }
									hx-target="#route-list"
									hx-swap="beforeend"
									hx-indicator="#loading-more"
								>
									Show more routes
								</button>
								<span id="loading-more" class="htmx-indicator loading">Loading…</span>
							}
						</div>
					}
				} else if data.Lat != "" {
					<p>No stops found nearby. <a href={ templ.SafeURL(fmt.Sprintf("/search?view=%s", data.View)) }>Try a different location</a>.</p>
				} else {
					<p class="loading" id="geo-loading">Getting your location…</p>
				}
			</div>
		</section>
	}
}

// RouteNearbyList renders the flat route-first view of nearby departures.
templ RouteNearbyList(routes []RouteNearbyRow) {
	for _, r := range routes {
		@routeNearbyRow(r)
	}
}

// RouteNearbyPartial renders additional routes for the "More" HTMX request.
templ RouteNearbyPartial(routes []RouteNearbyRow, hasMore bool, moreURL string) {
	for _, r := range routes {
		@routeNearbyRow(r)
	}
	<div id="load-more" hx-swap-oob="true">
		if hasMore {
			<button
				class="btn-more"
				hx-get={ moreURL }
				hx-target="#route-list"
				hx-swap="beforeend"
				hx-indicator="#loading-more"
			>
				Show more routes
			</button>
			<span id="loading-more" class="htmx-indicator loading">Loading…</span>
		}
	</div>
}

// routeNearbyRow renders a single route row with direction toggle.
templ routeNearbyRow(r RouteNearbyRow) {
	<article
		class={ "route-nearby-row", templ.KV("route-nearby-row--has-alt", r.HasAlt) }
		aria-label={ fmt.Sprintf("Route %s %s", r.RouteShort, r.DirectionText) }
		data-testid="route-row"
	>
		if r.HasAlt {
			<div class="direction-group">
				<div class="direction-primary">
					@routeRowContent(r.RouteShort, r.RouteColor, r.RouteTextColor, r.DirectionText, r.AltDirectionText, r.StopName, r.Scheduled, r.Realtime, r.MinutesAway, r.IsRealtime, r.IsLate, r.LaterTimes, r.Interval, true, fmt.Sprintf("/stops/%s/route/%s?dir=%d", r.StopID, r.RouteID, r.DirectionID), r.DistanceM, r.WalkDistM)
				</div>
				<div class="direction-alt" hidden>
					@routeRowContent(r.RouteShort, r.RouteColor, r.RouteTextColor, r.AltDirectionText, r.DirectionText, r.AltStopName, r.AltScheduled, r.AltRealtime, r.AltMinutesAway, r.AltIsRealtime, r.AltIsLate, r.AltLaterTimes, r.AltInterval, true, fmt.Sprintf("/stops/%s/route/%s?dir=%d", altStopID(r.AltStopID, r.StopID), r.RouteID, 1-r.DirectionID), r.AltDistanceM, r.AltWalkDistM)
				</div>
			</div>
		} else {
			@routeRowContent(r.RouteShort, r.RouteColor, r.RouteTextColor, r.DirectionText, "", r.StopName, r.Scheduled, r.Realtime, r.MinutesAway, r.IsRealtime, r.IsLate, r.LaterTimes, r.Interval, false, fmt.Sprintf("/stops/%s/route/%s?dir=%d", r.StopID, r.RouteID, r.DirectionID), r.DistanceM, r.WalkDistM)
		}
	</article>
}

// routeRowContent renders the inner content of a route row direction.
templ routeRowContent(routeShort string, routeColor string, routeTextColor string, directionText string, altDirectionText string, stopName string, scheduled string, realtime string, minutesAway int, isRealtime bool, isLate bool, laterTimes []LaterArrival, interval string, hasToggle bool, laterURL string, distanceM float64, walkDistM float64) {
	<div class="route-row-line1">
		if hasToggle {
			<button
				type="button"
				class="direction-toggle"
				aria-label={ fmt.Sprintf("Route %s, showing %s. Tap to switch to %s.", routeShort, directionText, altDirectionText) }
			>
				<span
					class="route-badge-sm"
					style={ fmt.Sprintf("background:#%s;color:#%s", routeColorOrDefault(routeColor), routeTextColorOrDefault(routeTextColor)) }
				>{ routeShort }</span>
				{ directionText }
				<span class="toggle-icon" aria-hidden="true">&#x21C4;</span>
			</button>
		} else {
			<span class="route-label-inline">
				<span
					class="route-badge-sm"
					style={ fmt.Sprintf("background:#%s;color:#%s", routeColorOrDefault(routeColor), routeTextColorOrDefault(routeTextColor)) }
				>{ routeShort }</span>
				if directionText != "" {
					{ directionText }
				}
			</span>
		}
		<span class="route-row-info">
			<span class="sr-only">{ departureAria(minutesAway, isRealtime, isLate, realtime, scheduled, stopName) }</span>
			<span aria-hidden="true">
				<span class="minutes-badge">{ fmt.Sprintf("%d", minutesAway) } min</span>
				<span class="info-sep"> at </span>
				if isRealtime {
					<span class={ "route-row-time", templ.KV("departure-late", isLate) }>{ realtime }</span>
					if isLate {
						<span class="late-label">late</span>
					}
					<span class="sched-note">(sched. { scheduled })</span>
				} else {
					<span class="route-row-time">{ scheduled }</span>
				}
				<span class="info-sep"> at </span>{ stopName }
			</span>
		</span>
	</div>
	<div class="route-row-line2">
		if len(laterTimes) > 0 {
			<span>Also </span>
			for i, lt := range laterTimes {
				if i > 0 {
					<span class="time-sep"> · </span>
				}
				if lt.IsRealtime {
					<span class="departure-time-sm">{ lt.Time }</span>
				} else {
					<span>{ lt.Time }</span>
				}
			}
		}
		if interval != "" {
			if len(laterTimes) > 0 {
				<span class="time-sep"> · </span>
			}
			<span class="route-interval">{ interval }</span>
		}
		<a
			href={ templ.SafeURL(laterURL) }
			class="later-link"
			aria-label="Get all later arrival times"
		>
			Later times &#x2192;
		</a>
		<span class="stop-distance" data-meters={ fmt.Sprintf("%.0f", distanceM) } data-walk-meters={ fmt.Sprintf("%.0f", walkDistM) }>{ fmtMetricDist(distanceM) } ({ walkMin(walkDistM) } min walk)</span>
	</div>
}

// NearbyStopsViewList renders the stop-first view of nearby departures.
templ NearbyStopsViewList(stops []StopViewData) {
	for _, stop := range stops {
		@stopCard(stop)
	}
}

// StopNearbyPartial renders additional stops for the "More" HTMX request.
templ StopNearbyPartial(stops []StopViewData, hasMore bool, moreURL string) {
	for _, stop := range stops {
		@stopCard(stop)
	}
	<div id="load-more-stops" hx-swap-oob="true">
		if hasMore {
			<button
				class="btn-more"
				hx-get={ moreURL }
				hx-target="#stop-list-items"
				hx-swap="beforeend"
				hx-indicator="#loading-more-stops"
			>
				Show more stops
			</button>
			<span id="loading-more-stops" class="htmx-indicator loading">Loading…</span>
		}
	</div>
}

// stopCard renders a single stop card in the stops-centric view.
templ stopCard(stop StopViewData) {
	<article class="card" data-testid="stop-card">
		<div style="display:flex;justify-content:space-between;align-items:baseline">
			<h3>
				<a href={ templ.SafeURL(fmt.Sprintf("/stops/%s", stop.StopID)) }>{ stop.StopName }</a>
			</h3>
			<span class="distance" data-meters={ fmt.Sprintf("%.0f", stop.DistanceM) } data-walk-meters={ fmt.Sprintf("%.0f", stop.WalkDistM) } data-testid="stop-distance">{ fmtMetricDist(stop.DistanceM) } ({ walkMin(stop.WalkDistM) } min walk)</span>
		</div>
		if stop.StopDesc != "" {
			<p class="stop-desc">{ stop.StopDesc }</p>
		}
		if len(stop.RouteGroups) > 0 {
			<ul role="list" aria-label={ fmt.Sprintf("Routes at %s", stop.StopName) } style="list-style:none;padding:0;margin:0">
				for _, rg := range stop.RouteGroups {
					<li class="stop-route-group">
						<div class="departure-row">
							<a
								href={ templ.SafeURL(fmt.Sprintf("/routes/%s", rg.RouteID)) }
								class="route-badge"
								style={ fmt.Sprintf("background:#%s;color:#%s", routeColorOrDefault(rg.RouteColor), routeTextColorOrDefault(rg.RouteTextColor)) }
								aria-label={ fmt.Sprintf("Route %s", rg.RouteShort) }
							>
								{ rg.RouteShort }
							</a>
							<div class="departure-details">
								if rg.DirectionText != "" {
									<span class="direction-label">{ rg.DirectionText }</span>
								}
								<div>{ rg.Headsign }</div>
								<div class="stop-route-times">
									for _, t := range rg.Times {
										@departureTime(t.IsRealtime, t.IsLate, t.Realtime, t.Scheduled, t.MinutesAway)
									}
								</div>
							</div>
						</div>
					</li>
				}
			</ul>
		} else {
			<p class="loading">No upcoming departures</p>
		}
	</article>
}

// DepartureRow renders a single departure entry.
templ DepartureRow(dep DepartureInfo) {
	<div class="departure-row">
		<a
			href={ templ.SafeURL(fmt.Sprintf("/routes/%s", dep.RouteID)) }
			class="route-badge"
			style={ fmt.Sprintf("background:#%s;color:#%s", routeColorOrDefault(dep.RouteColor), routeTextColorOrDefault(dep.RouteTextColor)) }
			aria-label={ fmt.Sprintf("Route %s", dep.RouteShort) }
		>
			{ dep.RouteShort }
		</a>
		<div class="departure-details">
			if dep.HasAlt {
				<div class="direction-group">
					<div class="direction-primary">
						if dep.DirectionText != "" {
							<button
								class="direction-toggle"
								aria-label={ fmt.Sprintf("Showing %s departures. Activate to show %s instead.", dep.DirectionText, dep.AltDirectionText) }
							>
								{ dep.DirectionText }
							</button>
						}
						<div>{ dep.Headsign }</div>
						<div>
							@departureTime(dep.IsRealtime, dep.IsLate, dep.Realtime, dep.Scheduled, dep.MinutesAway)
						</div>
					</div>
					<div class="direction-alt" hidden>
						if dep.AltDirectionText != "" {
							<button
								class="direction-toggle"
								aria-label={ fmt.Sprintf("Showing %s departures. Activate to show %s instead.", dep.AltDirectionText, dep.DirectionText) }
							>
								{ dep.AltDirectionText }
							</button>
						}
						<div>{ dep.AltHeadsign }</div>
						<div>
							@departureTime(dep.AltIsRealtime, dep.AltIsLate, dep.AltRealtime, dep.AltScheduled, dep.AltMinutesAway)
						</div>
						if dep.AltStopName != "" && dep.AltStopName != dep.PrimaryStopName {
							<div class="alt-stop-note">
								at { dep.AltStopName }
							</div>
						}
					</div>
				</div>
			} else {
				if dep.DirectionText != "" {
					<span class="direction-label">{ dep.DirectionText }</span>
				}
				<div>{ dep.Headsign }</div>
				<div>
					@departureTime(dep.IsRealtime, dep.IsLate, dep.Realtime, dep.Scheduled, dep.MinutesAway)
				</div>
			}
		</div>
	</div>
}

// departureTime renders the time portion of a departure.
templ departureTime(isRealtime bool, isLate bool, realtime string, scheduled string, minutesAway int) {
	if isRealtime {
		<span class={ "departure-time", templ.KV("departure-late", isLate) }>{ realtime }</span>
		if isLate {
			<span class="late-label">late</span>
		}
		<span class="departure-scheduled">
			(sched. { scheduled })
		</span>
	} else {
		<span class="departure-time">{ scheduled }</span>
	}
	<span aria-label={ fmt.Sprintf("%d minutes away", minutesAway) }>
		— { fmt.Sprintf("%d min", minutesAway) }
	</span>
}

// AlertSection renders service alerts with full text.
templ AlertSection(alerts []AlertDisplay) {
	<section aria-label="Service alerts" class="alerts-section">
		for _, alert := range alerts {
			<div class="alert-banner" role="alert">
				if alert.Effect != "" && alert.Effect != "Alert" {
					<strong class="alert-effect">{ alert.Effect }:</strong>
				}
				<strong>{ alert.HeaderText }</strong>
				if alert.DescText != "" && alert.DescText != alert.HeaderText {
					<p class="alert-desc">{ alert.DescText }</p>
				}
			</div>
		}
	</section>
}

func nearbyLocationLabel(data NearbyData) string {
	if data.Query != "" {
		return data.Query
	}
	// Fallback: nearest stop name
	if len(data.Routes) > 0 {
		return data.Routes[0].StopName
	}
	if len(data.StopViews) > 0 {
		return data.StopViews[0].StopName
	}
	return ""
}

func departureAria(minutesAway int, isRealtime bool, isLate bool, realtime string, scheduled string, stopName string) string {
	t := scheduled
	if isRealtime {
		t = realtime
	}
	s := fmt.Sprintf("Departs in %d minutes, at %s, from %s", minutesAway, t, stopName)
	if isRealtime && isLate {
		s = fmt.Sprintf("Departs in %d minutes, at %s, running late, scheduled %s, from %s", minutesAway, realtime, scheduled, stopName)
	}
	return s
}

func altStopID(altID, fallback string) string {
	if altID != "" {
		return altID
	}
	return fallback
}

func nearbyTabURL(view, lat, lon, query string) string {
	u := "/nearby?view=" + view
	if lat != "" && lon != "" {
		u += "&lat=" + lat + "&lon=" + lon
	}
	if query != "" {
		u += "&q=" + url.QueryEscape(query)
	}
	return u
}

// fmtMetricDist formats meters as a metric distance string.
func fmtMetricDist(meters float64) string {
	if meters < 1000 {
		return fmt.Sprintf("%d m", int(meters))
	}
	return fmt.Sprintf("%.1f km", meters/1000)
}

// walkMin returns the estimated walk time in minutes at 3 mph (80.467 m/min).
func walkMin(meters float64) string {
	min := int(math.Ceil(meters / 80.467))
	if min < 1 {
		min = 1
	}
	return fmt.Sprintf("%d", min)
}

func routeColorOrDefault(c string) string {
	if c == "" {
		return "1a5276"
	}
	return c
}

func routeTextColorOrDefault(c string) string {
	if c == "" {
		return "ffffff"
	}
	return c
}
